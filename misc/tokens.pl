#! /usr/bin/perl

use strict;
use warnings;
use List::MoreUtils qw(uniq);
use Text::MicroTemplate qw(render_mt);

my @tokens = map { chomp $_; $_ } <DATA>;

# output header
open my $fh, '>', 'include/h2o/token.h'
    or die "failed to open include/h2o/token.h:$!";
print $fh render_mt(<< 'EOT', \@tokens)->as_string;
? my $tokens = shift;
/* automatically generated by tokens.pl */
#ifndef h2o__token_h
#define h2o__token_h

typedef struct st_h2o_token_t {
    uv_buf_t buf;
} h2o_token_t;

? for my $i (0..$#$tokens) {
#define <?= normalize_name($tokens->[$i]) ?> (h2o__tokens + <?= $i ?>)
? }

extern const h2o_token_t h2o__tokens[<?= scalar @$tokens ?>];
const h2o_token_t *h2o_lookup_token(const char *name, size_t len);
int h2o_buf_is_token(const uv_buf_t *buf);

#endif
EOT
close $fh;

# output source
open $fh, '>', 'src/token.c'
    or die "failed to open src/token.c:$!";
print $fh render_mt(<< 'EOT', \@tokens)->as_string;
? my $tokens = shift;
/* automatically generated by tokens.pl */
#include "h2o.h"

const h2o_token_t h2o__tokens[] = {
? for my $i (0..$#$tokens) {
    { { H2O_STRLIT("<?= $tokens->[$i] ?>") } }<?= $i == $#$tokens ? '' : ',' ?>
? }
};

const h2o_token_t *h2o_lookup_token(const char *name, size_t len)
{
    switch (len) {
? for my $len (uniq sort { $a <=> $b } map { length $_ } @$tokens) {
    case <?= $len ?>:
        switch (h2o_tolower(name[<?= $len - 1 ?>])) {
?  my @tokens_of_len = grep { length($_) == $len } @$tokens;
?  for my $end (uniq sort map { substr($_, length($_) - 1) } @tokens_of_len) {
        case '<?= $end ?>':
?   my @tokens_of_end = grep { substr($_, length($_) - 1) eq $end } @tokens_of_len;
?   for my $token (@tokens_of_end) {
            if (h2o_lcstris_core(name, "<?= substr($token, 0, length($token) - 1) ?>", <?= length($token) - 1 ?>))
                return <?= normalize_name($token) ?>;
?   }
            break;
?  }
        }
        break;
? }
    }

    return NULL;
}

int h2o_buf_is_token(const uv_buf_t *buf)
{
    return &h2o__tokens[0].buf <= buf && buf <= &h2o__tokens[<?= $#$tokens ?>].buf;
}
EOT
close $fh;

sub normalize_name {
    my $n = shift;
    $n =~ s/^://;
    $n =~ s/-/_/g;
    $n =~ tr/a-z/A-Z/;
    "H2O_TOKEN_$n";
}

__DATA__
:authority
:method
:path
:scheme
:status
accept-charset
accept-encoding
accept-language
accept-ranges
accept
access-control-allow-origin
age
allow
authorization
cache-control
connection
content-disposition
content-encoding
content-language
content-length
content-location
content-range
content-type
cookie
date
etag
expect
expires
from
host
http2-settings
if-match
if-modified-since
if-none-match
if-range
if-unmodified-since
last-modified
link
location
max-forwards
proxy-authenticate
proxy-authorization
range
referer
refresh
retry-after
server
set-cookie
strict-transport-security
transfer-encoding
upgrade
user-agent
vary
via
www-authenticate
x-reproxy-url
